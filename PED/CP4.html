<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Labo04 - Punteros</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#punteros">Punteros</a>
<ul>
<li></li>
<li><a href="#punteros-propietarios">Punteros propietarios</a></li>
<li><a href="#punteros-en-parámetros">Punteros en parámetros</a>
<ul>
<li></li>
</ul>
</li>
<li><a href="#punteros-en-arreglos">Punteros en arreglos</a></li>
<li><a href="#arreglos-punteros-y-funciones.">Arreglos, punteros y funciones.</a></li>
<li><a href="#importancia-de-los-punteros-en-la-gestión-de-memoria-y-manipulación-de-datos">Importancia de los Punteros en la Gestión de Memoria y Manipulación de Datos</a></li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="punteros">Punteros</h1>
<p>En este laboratorio aprenderás sobre el uso de punteros, cómo declararlos, cómo utilizarlos, y su importancia en la gestión de memoria y manipulación de datos en programación.</p>
<h3 id="¿qué-son-los-punteros">¿Qué son los punteros?</h3>
<p>En tu computadora, cada variable que tu guardas, en realidad el valor de esa variable se guarda en <strong>una dirección de memoria</strong>. La dirección de memoria es el <strong>lugar físico</strong> donde la memoria <strong>está</strong> siendo guardada. Los punteros, van a permitirnos almacenar la dirección de memoria de cualquier variable y nos permitirán manipularla.</p>
<p>Como tal, una variable tiene 3 características fundamentales:</p>
<ul>
<li><strong>Su valor</strong></li>
<li><strong>Su nombre</strong></li>
<li><strong>Dirección de memoria</strong></li>
</ul>
<p>Entonces, a simple modo podemos decir que un puntero es como un tipo especial de variable, que tiene las características que mencionamos anteriormente, como todas las variables, con la única <strong>diferencia</strong> que su valor no será un dato como tal, si no que era una dirección de memoria que esta <strong>apuntando</strong> a otro objeto (int, float, chat).</p>
<p>Entonces los punteros nos servirán para acceder a esos objetos a los cuales apuntan, es decir, hacer referencia a ellos usando su dirección de memoria. Ahora, si tu un puntero no lo inicializas bien, va a apuntar a una direccion de memoria <strong>no valida</strong>.</p>
<h3 id="ejemplo-de-definición-de-puntero">Ejemplo de definición de puntero</h3>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> 
<span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span> 
</code></pre>
<h3 id="¿qué-significan-el--y-el--en-los-punteros">¿Qué significan el <code>*</code> y el <code>&amp;</code> en los punteros?</h3>
<p>Cuando trabajamos con punteros, es esencial entender el significado de los operadores <code>*</code> y <code>&amp;</code> porque son clave para manipular direcciones de memoria y valores.</p>
<h3 id="el-operador--operador-de-referencia">El operador <code>&amp;</code>: Operador de Referencia</h3>
<p>El <strong>ampersand (<code>&amp;</code>)</strong> se utiliza para obtener la <strong>dirección de memoria</strong> de una variable. Este proceso se llama <strong>referenciar</strong> una variable.</p>
<h4 id="ejemplo">Ejemplo:</h4>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
</code></pre>
<p>Aquí, <code>p</code> es un puntero que almacena la <strong>dirección de memoria</strong> de la variable <code>a</code>. En este caso, <code>&amp;a</code> proporciona la dirección donde <code>a</code> está almacenada en la memoria.</p>
<h3 id="el-operador--operador-de-desreferencia">El operador <code>*</code>: Operador de Desreferencia</h3>
<p>El asterisco (<code>*</code>) se utiliza para acceder al <strong>valor</strong> almacenado en la dirección de memoria que el puntero contiene. Este proceso se llama <strong>desreferenciar</strong> un puntero.</p>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token macro property">#<span class="token directive keyword">include</span>  <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">int</span>  a  <span class="token operator">=</span>  <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">*</span>  p  <span class="token operator">=</span>  <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>

<span class="token keyword">int</span>  <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span>  argc<span class="token punctuation">,</span>  <span class="token keyword">char</span><span class="token operator">*</span>  argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
	std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout  <span class="token operator">&lt;&lt;</span>  <span class="token string">"Valor de a: "</span>  <span class="token operator">&lt;&lt;</span>  a  <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
	std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout  <span class="token operator">&lt;&lt;</span>  <span class="token string">"Dirección de a: "</span>  <span class="token operator">&lt;&lt;</span>  <span class="token operator">&amp;</span>a  <span class="token operator">&lt;&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
	std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout  <span class="token operator">&lt;&lt;</span>  <span class="token string">"Valor de p: "</span>  <span class="token operator">&lt;&lt;</span>  p  <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
	std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout  <span class="token operator">&lt;&lt;</span>  <span class="token string">"Valor de *p: "</span>  <span class="token operator">&lt;&lt;</span>  <span class="token operator">*</span>p  <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
	std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout  <span class="token operator">&lt;&lt;</span>  <span class="token string">"Dirección de p: "</span>  <span class="token operator">&lt;&lt;</span>  <span class="token operator">&amp;</span>p  <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span>  <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</code></pre>
<p>En este ejemplo, <code>*p</code> accede al <strong>valor</strong> almacenado en la dirección de memoria a la que <code>p</code> apunta, es decir, el valor de <code>a</code>. La expresión <code>*p</code> es equivalente a acceder directamente a <code>a</code>.</p>
<h2 id="punteros-propietarios">Punteros propietarios</h2>
<p>Cuando un programa necesita más espacio para guardar algo grande, usa una parte especial de la memoria llamada <strong><em>heap</em></strong>. Cuando hace esto, el programa recibe una “dirección” que le dice dónde se guarda ese algo, y esa dirección se guarda en forma de puntero. Este tipo de punteros se llaman <strong>punteros propietarios</strong>.</p>
<p>El problema es que, cuando terminas de usar ese espacio, el programa no lo libera automáticamente. Tú tienes que decirle al programa que lo haga, porque si no, el espacio sigue ocupado y el programa o incluso otros programas no podrán usarlo. Esto se llama <strong>“fuga de memoria”</strong>, porque el espacio queda atrapado sin poder ser reutilizado.</p>
<p>Para manejar esto, se usan dos comandos importantes: <code>new</code> para <strong>pedir</strong> espacio en el heap y <code>delete</code> para <strong>liberar</strong> ese espacio cuando ya no lo necesitas.</p>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>  

    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Valor en el heap: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>

    delete p<span class="token punctuation">;</span>  
    
    p <span class="token operator">=</span> nullptr<span class="token punctuation">;</span> 

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>En este ejemplo, hemos usado <code>new</code> para pedir espacio en el heap y almacenamos la dirección de esa memoria en el puntero <code>p</code>. Usamos <code>p</code> para almacenar el valor <code>42</code> en esa memoria.</p>
<p>Si no liberamos la memoria con <code>delete</code>, esa memoria sigue ocupada aunque ya no la estemos usando, lo que genera una <strong>fuga de memoria</strong>.</p>
<h3 id="¿que-es-nullptr">¿Que es nullptr?</h3>
<p><code>nullptr</code> es un valor especial en C++ que representa un puntero que <strong>no apunta a ninguna dirección de memoria válida</strong>. En otras palabras, es una forma de inicializar o restablecer un puntero para indicar que <strong>no tiene un objeto o memoria a la cual apuntar</strong>.</p>
<p>Después de liberar la memoria con <code>delete</code>, es buena práctica asignar <code>nullptr</code> al puntero. Esto ayuda a evitar que el puntero siga apuntando a una ubicación de memoria que ya no es válida (puntero colgante).</p>
<h2 id="punteros-en-parámetros">Punteros en parámetros</h2>
<h4 id="paso-por-valor-y-por-referencia">Paso por valor y por referencia</h4>
<p><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXc7MKyKN-EU3Zl3Ow5J_iq_VmB7bKNq1HOjUhy6yTTnj6RmHP9H4OYZvZrE18oToHvF8SCrq_zT2Dl8I0dlw_1aGOW1ScUkAL-NadMddpMCF5bZ2TyTYY-Hr_EDfvBIoDxXi9nwUp_Tx1Z1uMyfDUhKGj2U4n7E3zqELe1wet_ZqCBctADggnI?key=Ebc5RBD3qg94hAq1Y-1isQ" alt=""></p>
<p>Uno de los mejores usos de los punteros es que nos permite optimizar nuestro programa. Y un ejemplo muy claro, es en las funciones.</p>
<p>En los laboratorios anteriores estudiamos que los parámetros los podemos pasar a una función por <strong>por valor</strong>, al hacerlo estamos dando a la función una <strong>copia del valor original</strong>. Esto significa que cualquier cambio que la función haga en ese valor <strong>no afectará</strong> al valor original fuera de la función.</p>
<h4 id="ejemplo-de-función-con-parametros-por-valor">Ejemplo de función con parametros por valor</h4>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">Sumar</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  x <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  y <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Dentro de la función: x = "</span> <span class="token operator">&lt;&lt;</span> x 
            <span class="token operator">&lt;&lt;</span> <span class="token string">", y = "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

  <span class="token function">Sumar</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>

  std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Fuera de la función: a = "</span> <span class="token operator">&lt;&lt;</span> a 
            <span class="token operator">&lt;&lt;</span> <span class="token string">", b = "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Por otro lado, cuando pasamos un parámetro <strong>por referencia</strong>, le estamos dando a la función acceso directo al valor original mediante su dirección de memoria. Esto significa que cualquier cambio que la función haga <strong>sí afectará</strong> al valor original fuera de la función.</p>
<h4 id="ejemplo-de-función-con-parametros-por-referencia">Ejemplo de función con parametros por referencia</h4>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">SumarPorReferencia</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  x <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  y <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Dentro de la función: x = "</span> <span class="token operator">&lt;&lt;</span> x 
            <span class="token operator">&lt;&lt;</span> <span class="token string">", y = "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

  <span class="token function">SumarPorReferencia</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>

  std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Fuera de la función: a = "</span> <span class="token operator">&lt;&lt;</span> a 
            <span class="token operator">&lt;&lt;</span> <span class="token string">", b = "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre>
<h2 id="punteros-en-arreglos">Punteros en arreglos</h2>
<p>En C++, los <strong>arreglos</strong> y los <strong>punteros</strong> están estrechamente relacionados. Un arreglo es básicamente una secuencia contigua de elementos almacenados en la memoria, y el <strong>nombre del arreglo</strong> es en realidad un <strong>puntero</strong> que apunta a la dirección de memoria del primer elemento del arreglo.</p>
<p>Por lo tanto, no es necesario usar el operador <code>&amp;</code> para obtener la dirección del primer elemento del arreglo, ya que el nombre del arreglo ya es un puntero.</p>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> arr<span class="token punctuation">;</span>

    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Primer elemento (usando puntero): "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>

    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Segundo elemento : "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>El uso de punteros permite que las funciones puedan trabajar con arreglos sin tener que pasar copias de los datos, lo que ahorra memoria y tiempo de ejecución.</p>
<h2 id="arreglos-punteros-y-funciones.">Arreglos, punteros y funciones.</h2>
<p>Cuando se pasa un arreglo a una función, en realidad lo que se está pasando es un <strong>puntero</strong> que apunta al primer elemento del arreglo. Esto se debe a que los arreglos son tratados como punteros cuando se pasan a funciones, permitiendo acceder y manipular directamente los elementos del arreglo.</p>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token comment">// Función que recibe un puntero a un arreglo y su tamaño</span>
<span class="token keyword">void</span> <span class="token function">ModificarArreglo</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment">// Modifica cada elemento sumando 10</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// Arreglo original</span>

    <span class="token comment">// Llamada a la función, pasando el arreglo y su tamaño</span>
    <span class="token function">ModificarArreglo</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Mostrar los valores modificados</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Elemento "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre>
<p>En la función <code>ModificarArreglo</code>, se recorre el arreglo y se le suma 10 a cada elemento. Esto modifica los elementos directamente en el arreglo original <code>arr</code> del <code>main</code> porque hemos pasado un puntero al arreglo.</p>
<p>La modificación es visible en el <code>main</code> después de la llamada a la función, ya que se trabaja sobre la misma ubicación de memoria.</p>
<h2 id="importancia-de-los-punteros-en-la-gestión-de-memoria-y-manipulación-de-datos">Importancia de los Punteros en la Gestión de Memoria y Manipulación de Datos</h2>
<p>Los punteros juegan un papel fundamental en la <strong>gestión eficiente de la memoria</strong> y en la <strong>manipulación de datos</strong> dentro de la programación.</p>
<p>En muchas aplicaciones, no siempre sabemos cuánta memoria será necesaria durante la ejecución del programa. Los punteros nos permiten <strong>asignar y liberar memoria dinámica</strong> de manera manual, lo cual es crucial para gestionar correctamente los recursos en programas que requieren mucha memoria o cuya cantidad de datos no es fija.</p>
<p>Al usar punteros, es posible <strong>optimizar el rendimiento</strong> del programa al reducir el uso de memoria y permitir un acceso más rápido a los datos.</p>

    </div>
  </div>
</body>

</html>
