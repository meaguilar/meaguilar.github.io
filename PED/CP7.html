<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CP7</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#estructuras-de-datos-árboles">Estructuras de Datos: Árboles</a>
<ul>
<li><a href="#¿qué-es-un-árbol">¿Qué es un Árbol?</a></li>
<li><a href="#tipos-de-árboles">Tipos de Árboles</a></li>
<li><a href="#¿qué-es-un-árbol-binario">¿Qué es un Árbol Binario?</a></li>
<li><a href="#representación-de-un-árbol-binario-en-c">Representación de un Árbol binario en C++</a></li>
<li><a href="#operaciones-básicas-en-árboles-binarios">Operaciones Básicas en Árboles Binarios</a></li>
<li><a href="#red-black-tree">Red-Black Tree</a></li>
<li><a href="#librería-de-árboles-c">Librería de Árboles C++</a></li>
<li><a href="#métodos-básicos-de-librerías-stdset-y-stdmap">Métodos básicos de librerías std::set y std::map</a></li>
<li><a href="#ejemplo-1-registro-de-visitantes-frecuentes-uso-de-set">Ejemplo 1: Registro de visitantes frecuentes (uso de set)</a></li>
<li><a href="#ejemplo-2-sistema-de-inventario-de-ferretería-uso-de-map">Ejemplo 2: Sistema de inventario de ferretería (uso de map)</a></li>
</ul>
</li>
<li><a href="#anexos">Anexos</a></li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="estructuras-de-datos-árboles">Estructuras de Datos: Árboles</h1>
<p>En este laboratorio estudiaremos los <strong>árboles</strong>, una estructura de datos que permite organizar y manipular información de forma jerárquica que es fundamental en la organización y manipulación de datos en muchos campos de la informática.</p>
<h2 id="¿qué-es-un-árbol">¿Qué es un Árbol?</h2>
<p>A diferencia de estructuras como pilas y colas, que organizan los datos de forma lineal, un <strong>árbol</strong> es una estructura de datos jerárquica compuesta por nodos conectados entre sí mediante aristas. A diferencia de las estructuras lineales (como pilas y colas), un árbol organiza los datos de manera no lineal, permitiendo una estructura de ramificación.</p>
<p>El nodo principal del árbol es llamado <strong>raíz</strong>, y cada nodo puede tener múltiples <strong>hijos</strong>. Un nodo sin hijos es conocido como <strong>hoja</strong>.</p>
<h3 id="características-importantes-de-los-árboles">Características importantes de los árboles:</h3>
<ul>
<li><strong>Raíz</strong>: El nodo en la parte superior del árbol.</li>
<li><strong>Hojas</strong>: Nodos sin hijos.</li>
<li><strong>Padre</strong>: Un nodo que tiene uno o más hijos.</li>
<li><strong>Hijos</strong>: Nodos que descienden directamente de otro nodo.</li>
<li><strong>Profundidad</strong>: La distancia de un nodo a la raíz.</li>
<li><strong>Altura</strong>: La longitud del camino más largo desde un nodo hasta una hoja.</li>
</ul>
<p><img src="https://raw.githubusercontent.com/meaguilar/meaguilar.github.io/refs/heads/main/PED/Imagenes/CP7/tree-nodes-types.png" alt="tree-nodes-types"></p>
<h2 id="tipos-de-árboles">Tipos de Árboles</h2>
<ol>
<li><strong>Árbol General</strong>: No hay restricciones en el número de hijos de un nodo.</li>
<li><strong>Árbol Binario</strong>: Cada nodo tiene como máximo dos hijos.</li>
<li><strong>Árbol Binario de Búsqueda (BST)</strong>: En un árbol binario de búsqueda, los valores del subárbol izquierdo son menores que los del nodo, y los del subárbol derecho son mayores.</li>
<li><strong>Árbol AVL</strong>: Árbol binario de búsqueda balanceado donde la diferencia de altura entre subárboles de cualquier nodo no puede ser mayor que 1.</li>
</ol>
<ul>
<li>En este laboratorio nos centraremos más en estudiar los <strong>Árboles binarios</strong>.</li>
</ul>
<h2 id="¿qué-es-un-árbol-binario">¿Qué es un Árbol Binario?</h2>
<p>Un <strong>árbol binario</strong> es una estructura de datos en la que cada nodo tiene como máximo dos hijos, llamados <strong>hijo izquierdo</strong> e <strong>hijo derecho</strong>. Los árboles binarios son muy eficientes para realizar operaciones como la búsqueda, inserción y eliminación de datos.</p>
<p>Un <strong>árbol binario perfecto</strong> es aquel en el que todos los nodos internos tienen exactamente dos hijos y todas las hojas se encuentran al mismo nivel. Por el contrario, un <strong>árbol binario no perfecto</strong> es aquel en el que no todos los nodos tienen dos hijos o las hojas no están al mismo nivel, lo que genera una estructura menos simétrica.</p>
<p><img src="https://raw.githubusercontent.com/meaguilar/meaguilar.github.io/refs/heads/main/PED/Imagenes/CP7/balance-tree.png" alt="balance-tree"></p>
<h2 id="representación-de-un-árbol-binario-en-c">Representación de un Árbol binario en C++</h2>
<h3 id="definición-de-un-nodo">Definición de un nodo</h3>
<p>En C++, cada nodo de un árbol binario se puede definir mediante una estructura que contiene los datos a guardar y dos punteros, uno hacia el hijo izquierdo y otro hacia el hijo derecho.</p>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword">struct</span> Datos <span class="token punctuation">{</span>
    <span class="token keyword">int</span> id<span class="token punctuation">;</span>         
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>string nombre<span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> Nodo <span class="token punctuation">{</span>
    Datos dato<span class="token punctuation">;</span>         <span class="token comment">// Valor almacenado</span>
    Nodo<span class="token operator">*</span> izquierda<span class="token punctuation">;</span>    <span class="token comment">// Puntero al hijo izquierdo</span>
    Nodo<span class="token operator">*</span> derecha<span class="token punctuation">;</span>      <span class="token comment">// Puntero al hijo derecho</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="operaciones-básicas-en-árboles-binarios">Operaciones Básicas en Árboles Binarios</h2>
<h3 id="insertar-un-nodo">1. Insertar un nodo</h3>
<p>Vamos a insertar un nodo en el árbol binario comparando el <strong>id</strong> del campo <code>Datos</code>. Si el <strong>id</strong> del nuevo nodo es menor que el nodo actual, lo insertamos en el subárbol izquierdo; si es mayor, en el subárbol derecho.</p>
<pre class=" language-c"><code class="prism ++ language-c">Nodo<span class="token operator">*</span> <span class="token function">Insertar</span><span class="token punctuation">(</span>Nodo<span class="token operator">*</span> raiz<span class="token punctuation">,</span> Datos nuevo_dato<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>raiz <span class="token operator">==</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Nodo<span class="token operator">*</span> nuevo_nodo <span class="token operator">=</span> new <span class="token function">Nodo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        nuevo_nodo<span class="token operator">-&gt;</span>dato <span class="token operator">=</span> nuevo_dato<span class="token punctuation">;</span>
        nuevo_nodo<span class="token operator">-&gt;</span>izquierda <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
        nuevo_nodo<span class="token operator">-&gt;</span>derecha <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
        <span class="token keyword">return</span> nuevo_nodo<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>nuevo_dato<span class="token punctuation">.</span>id <span class="token operator">&lt;</span> raiz<span class="token operator">-&gt;</span>dato<span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        raiz<span class="token operator">-&gt;</span>izquierda <span class="token operator">=</span> <span class="token function">Insertar</span><span class="token punctuation">(</span>raiz<span class="token operator">-&gt;</span>izquierda<span class="token punctuation">,</span> nuevo_dato<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        raiz<span class="token operator">-&gt;</span>derecha <span class="token operator">=</span> <span class="token function">Insertar</span><span class="token punctuation">(</span>raiz<span class="token operator">-&gt;</span>derecha<span class="token punctuation">,</span> nuevo_dato<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> raiz<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="buscar-un-nodo">2. Buscar un nodo</h3>
<p>Para buscar un nodo en el árbol, compararemos el <strong>id</strong> del campo <code>Datos</code> para determinar si el nodo se encuentra en el árbol.</p>
<pre class=" language-c"><code class="prism ++ language-c">bool <span class="token function">Buscar</span><span class="token punctuation">(</span>Nodo<span class="token operator">*</span> raiz<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>raiz <span class="token operator">==</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>raiz<span class="token operator">-&gt;</span>dato<span class="token punctuation">.</span>id <span class="token operator">==</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">&lt;</span> raiz<span class="token operator">-&gt;</span>dato<span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">Buscar</span><span class="token punctuation">(</span>raiz<span class="token operator">-&gt;</span>izquierda<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">Buscar</span><span class="token punctuation">(</span>raiz<span class="token operator">-&gt;</span>derecha<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="recorrer-un-árbol-binario">3. Recorrer un árbol binario</h3>
<p>Los <strong>recorridos de un árbol binario</strong> son formás de visitar todos los nodos del árbol siguiendo un orden específico. Existen tres tipos principales de recorridos: <strong>inorden</strong>, <strong>preorden</strong> y <strong>postorden</strong>. La principal diferencia entre estos recorridos es el momento en que se visita el nodo <strong>padre</strong> en relación con su hijo izquierdo e hijo derecho.</p>
<ul>
<li><strong>Recorrido Inorden (IPD):</strong> En el recorrido <strong>inorden</strong>, primero se visita el <strong>hijo izquierdo</strong>, luego se <strong>visita el nodo</strong> padre, y finalmente se visita el <strong>hijo derecho</strong>.</li>
</ul>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token keyword">void</span> <span class="token function">InOrden</span><span class="token punctuation">(</span>Nodo<span class="token operator">*</span> raiz<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>raiz <span class="token operator">!=</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">InOrden</span><span class="token punctuation">(</span>raiz<span class="token operator">-&gt;</span>izquierda<span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ID: "</span> <span class="token operator">&lt;&lt;</span> raiz<span class="token operator">-&gt;</span>dato<span class="token punctuation">.</span>id <span class="token operator">&lt;&lt;</span> <span class="token string">", Nombre: "</span> <span class="token operator">&lt;&lt;</span> raiz<span class="token operator">-&gt;</span>dato<span class="token punctuation">.</span>nombre <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
        <span class="token function">InOrden</span><span class="token punctuation">(</span>raiz<span class="token operator">-&gt;</span>derecha<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p><img src="https://raw.githubusercontent.com/meaguilar/meaguilar.github.io/refs/heads/main/PED/Imagenes/CP7/inorder-visualization.png" alt="inorder-visualization"></p>
<ul>
<li><strong>Recorrido Preorden (PID):</strong> En el recorrido <strong>preorden</strong>, primero se <strong>visita el nodo</strong> padre, luego se visita el <strong>hijo izquierdo</strong>, y finalmente se visita el <strong>hijo derecho</strong>.</li>
</ul>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token keyword">void</span> <span class="token function">PreOrden</span><span class="token punctuation">(</span>Nodo<span class="token operator">*</span> raiz<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>raiz <span class="token operator">!=</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ID: "</span> <span class="token operator">&lt;&lt;</span> raiz<span class="token operator">-&gt;</span>dato<span class="token punctuation">.</span>id <span class="token operator">&lt;&lt;</span> <span class="token string">", Nombre: "</span> <span class="token operator">&lt;&lt;</span> raiz<span class="token operator">-&gt;</span>dato<span class="token punctuation">.</span>nombre <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
        <span class="token function">PreOrden</span><span class="token punctuation">(</span>raiz<span class="token operator">-&gt;</span>izquierda<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">PreOrden</span><span class="token punctuation">(</span>raiz<span class="token operator">-&gt;</span>derecha<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p><img src="https://raw.githubusercontent.com/meaguilar/meaguilar.github.io/refs/heads/main/PED/Imagenes/CP7/preorder-visualization.png" alt="preorder-visualization"></p>
<ul>
<li><strong>Recorrido Postorden (IDP):</strong> En el recorrido <strong>postorden</strong>, primero se visita el <strong>hijo izquierdo</strong>, luego se visita el <strong>hijo derecho</strong>, y finalmente se visita el <strong>nodo padre</strong>.</li>
</ul>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token keyword">void</span> <span class="token function">PostOrden</span><span class="token punctuation">(</span>Nodo<span class="token operator">*</span> raiz<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>raiz <span class="token operator">!=</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">PostOrden</span><span class="token punctuation">(</span>raiz<span class="token operator">-&gt;</span>izquierda<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">PostOrden</span><span class="token punctuation">(</span>raiz<span class="token operator">-&gt;</span>derecha<span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ID: "</span> <span class="token operator">&lt;&lt;</span> raiz<span class="token operator">-&gt;</span>dato<span class="token punctuation">.</span>id <span class="token operator">&lt;&lt;</span> <span class="token string">", Nombre: "</span> <span class="token operator">&lt;&lt;</span> raiz<span class="token operator">-&gt;</span>dato<span class="token punctuation">.</span>nombre <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p><img src="https://raw.githubusercontent.com/meaguilar/meaguilar.github.io/refs/heads/main/PED/Imagenes/CP7/postorder-visualization.png" alt="postorder-visualization"></p>
<h3 id="eliminar-un-nodo">4. <strong>Eliminar un Nodo</strong></h3>
<p>La eliminación de un nodo sigue las mismás reglas, pero comparando siempre el <strong>id</strong> del campo <code>Datos</code> para encontrar el nodo a eliminar.</p>
<pre class=" language-c"><code class="prism ++ language-c">Nodo<span class="token operator">*</span> <span class="token function">EncontrarMin</span><span class="token punctuation">(</span>Nodo<span class="token operator">*</span> nodo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>nodo<span class="token operator">-&gt;</span>izquierda <span class="token operator">!=</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        nodo <span class="token operator">=</span> nodo<span class="token operator">-&gt;</span>izquierda<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> nodo<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Nodo<span class="token operator">*</span> <span class="token function">Eliminar</span><span class="token punctuation">(</span>Nodo<span class="token operator">*</span> raiz<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>raiz <span class="token operator">==</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> raiz<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">&lt;</span> raiz<span class="token operator">-&gt;</span>dato<span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        raiz<span class="token operator">-&gt;</span>izquierda <span class="token operator">=</span> <span class="token function">Eliminar</span><span class="token punctuation">(</span>raiz<span class="token operator">-&gt;</span>izquierda<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">&gt;</span> raiz<span class="token operator">-&gt;</span>dato<span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        raiz<span class="token operator">-&gt;</span>derecha <span class="token operator">=</span> <span class="token function">Eliminar</span><span class="token punctuation">(</span>raiz<span class="token operator">-&gt;</span>derecha<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>raiz<span class="token operator">-&gt;</span>izquierda <span class="token operator">==</span> nullptr <span class="token operator">&amp;&amp;</span> raiz<span class="token operator">-&gt;</span>derecha <span class="token operator">==</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            delete raiz<span class="token punctuation">;</span>
            raiz <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>raiz<span class="token operator">-&gt;</span>izquierda <span class="token operator">==</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Nodo<span class="token operator">*</span> temp <span class="token operator">=</span> raiz<span class="token punctuation">;</span>
            raiz <span class="token operator">=</span> raiz<span class="token operator">-&gt;</span>derecha<span class="token punctuation">;</span>
            delete temp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>raiz<span class="token operator">-&gt;</span>derecha <span class="token operator">==</span> nullptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Nodo<span class="token operator">*</span> temp <span class="token operator">=</span> raiz<span class="token punctuation">;</span>
            raiz <span class="token operator">=</span> raiz<span class="token operator">-&gt;</span>izquierda<span class="token punctuation">;</span>
            delete temp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            Nodo<span class="token operator">*</span> temp <span class="token operator">=</span> <span class="token function">EncontrarMin</span><span class="token punctuation">(</span>raiz<span class="token operator">-&gt;</span>derecha<span class="token punctuation">)</span><span class="token punctuation">;</span>
            raiz<span class="token operator">-&gt;</span>dato <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>dato<span class="token punctuation">;</span>
            raiz<span class="token operator">-&gt;</span>derecha <span class="token operator">=</span> <span class="token function">Eliminar</span><span class="token punctuation">(</span>raiz<span class="token operator">-&gt;</span>derecha<span class="token punctuation">,</span> temp<span class="token operator">-&gt;</span>dato<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> raiz<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="ejemplo-completo-de-los-recorridos-y-busquedas-manuales-de-árboles-binarios">Ejemplo completo de los recorridos y busquedas manuales de árboles binarios</h3>
<p>Puedes consultar un ejemplo completo de los recorridos y búsquedas manuales en árboles binarios en el siguiente repositorio: <a href="https://github.com/UCASV/RecursosExtraPED/blob/main/ArbolesBinarios/ArbolesManual.cc">Repositorio - Árboles manual</a></p>
<h2 id="red-black-tree">Red-Black Tree</h2>
<p>Un <strong>árbol rojo-negro (Red-Black Tree)</strong> es un <strong>árbol binario de búsqueda auto-balanceado</strong> que garantiza operaciones en <strong>O(log n)</strong> para inserción, búsqueda y borrado. Se usa como estructura interna de <code>std::set</code> y <code>std::map</code>.</p>
<p><img src="https://raw.githubusercontent.com/meaguilar/meaguilar.github.io/refs/heads/main/PED/Imagenes/CP7/Red-Black-Tree.png" alt="Red Black Tree"></p>
<h3 id="ideas-clave">Ideas clave</h3>
<ul>
<li><strong>Orden BST</strong>: para cada nodo, todos los valores del subárbol izquierdo son menores y los del derecho mayores.</li>
<li><strong>Color por nodo</strong>: cada nodo es <strong>rojo</strong> o <strong>negro</strong> (solo un bit extra).</li>
<li><strong>Reglas de balance</strong> (intuitivas):
<ol>
<li>La <strong>raíz</strong> es negra.</li>
<li>Todas las <strong>hojas nulas (NIL)</strong> se consideran negras.</li>
<li>Un <strong>nodo rojo no puede tener hijo rojo</strong> (no hay dos rojos consecutivos).</li>
<li>Todo <strong>camino desde un nodo hasta sus hojas NIL tiene el mismo número de nodos negros</strong> (altura negra constante).</li>
</ol>
</li>
</ul>
<p>Cuando una inserción o eliminación rompe alguna regla, el árbol realiza <strong>rotaciones</strong> (izq./der.) y <strong>recoloraciones</strong> para recuperar el balance.</p>
<p><strong>¿Qué ganamos?</strong> Un árbol balanceado siempre, sin necesidad de re-balanceos costosos como en peores casos de un BST normal.</p>
<h2 id="librería-de-árboles-c">Librería de Árboles C++</h2>
<p>En este laboratorio utilizaremos la librería <code>std::set</code> y <code>std::map</code>, que implementa un árbol de búsqueda balanceado, comúnmente un <strong>Red-Black Tree</strong>. Esto garantiza que el código sea eficiente en términos de velocidad de ejecución.</p>
<p><img src="https://raw.githubusercontent.com/meaguilar/meaguilar.github.io/refs/heads/main/PED/Imagenes/CP7/Map-vs-Set.png" alt="Map vs Set"></p>
<h3 id="propiedades-de-la-librería-stdset">Propiedades de la librería <code>std::set</code></h3>
<ul>
<li><strong>Elementos únicos</strong>: Cada valor dentro del conjunto es <strong>único</strong>; si se intenta insertar un elemento duplicado, será ignorado automáticamente.</li>
<li><strong>Orden automático</strong>: Los elementos se almacenan de forma <strong>ordenada ascendentemente</strong> según el operador <code>&lt;</code> del tipo de dato (puede personalizarse con un comparador).</li>
<li><strong>Estructura interna balanceada</strong>: Está implementado como un <strong>árbol rojo–negro</strong>, lo que garantiza operaciones eficientes de inserción, búsqueda y eliminación en tiempo <strong>O(log n)</strong>.</li>
<li><strong>Inmutabilidad de elementos</strong>: Los valores almacenados dentro del <code>set</code> son <strong>constantes</strong>; no se pueden modificar directamente una vez insertados, ya que esto alteraría el orden del árbol.</li>
<li><strong>Ideal para pruebas de pertenencia</strong>: Es especialmente útil cuando se necesita saber rápidamente si un elemento existe en una colección sin duplicados.</li>
</ul>
<h3 id="propiedades-de-la-librería-stdmap">Propiedades de la librería <code>std::map</code></h3>
<ul>
<li><strong>Clave–Valor</strong>: Cada elemento del mapa almacena un par formado por una <strong>clave única</strong> y un <strong>valor asociado</strong>.</li>
<li><strong>Sin claves duplicadas</strong>: No se pueden repetir las claves; si insertas una clave existente, el valor anterior se reemplaza.</li>
<li><strong>Ordenado automáticamente</strong>: Los elementos se ordenan según la clave, en orden ascendente por defecto (<code>&lt;</code>).</li>
<li><strong>Acceso rápido</strong>: Permite acceder, insertar o eliminar elementos en tiempo logarítmico (<em>O(log n)</em>), gracias a su implementación como <strong>árbol rojo–negro</strong>.</li>
<li><strong>Modificable por valor</strong>: Es posible cambiar el valor asociado a una clave existente sin afectar el orden del árbol.</li>
</ul>
<h3 id="comparación-entre-stdset-y-stdmap">Comparación entre <code>std::set</code> y <code>std::map</code></h3>

<table>
<thead>
<tr>
<th>Característica</th>
<th><code>std::set</code></th>
<th><code>std::map</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Tipo de dato almacenado</strong></td>
<td>Solo almacena <strong>valores únicos</strong></td>
<td>Almacena <strong>pares (clave, valor)</strong></td>
</tr>
<tr>
<td><strong>Definición</strong></td>
<td><code>std::set&lt;T&gt;</code></td>
<td><code>std::map&lt;Key, Value&gt;</code></td>
</tr>
<tr>
<td><strong>Clave</strong></td>
<td>El <strong>valor mismo</strong> actúa como clave</td>
<td>La <strong>clave</strong> y el <strong>valor</strong> son independientes</td>
</tr>
<tr>
<td><strong>Duplicados</strong></td>
<td>No se permiten valores duplicados</td>
<td>No se permiten <strong>claves</strong> duplicadas (los valores pueden repetirse)</td>
</tr>
<tr>
<td><strong>Orden</strong></td>
<td>Ordenado automáticamente por el valor (<code>&lt;</code>)</td>
<td>Ordenado automáticamente por la <strong>clave</strong> (<code>&lt;</code>)</td>
</tr>
<tr>
<td><strong>Acceso a elementos</strong></td>
<td>Solo se puede <strong>buscar o recorrer</strong> valores</td>
<td>Se puede <strong>buscar por clave</strong> y <strong>modificar el valor asociado</strong></td>
</tr>
<tr>
<td><strong>Inserción</strong></td>
<td><code>insert(valor)</code> o <code>emplace(valor)</code></td>
<td><code>insert({clave, valor})</code> o <code>operator[](clave) = valor</code></td>
</tr>
<tr>
<td><strong>Modificación de elementos</strong></td>
<td>No es posible modificar un elemento directamente</td>
<td>El valor puede modificarse mediante la clave</td>
</tr>
<tr>
<td><strong>Uso típico</strong></td>
<td>Verificar existencia, eliminar duplicados, mantener ordenado un conjunto de valores únicos</td>
<td>Crear diccionarios, tablas de correspondencia o contadores clave→valor</td>
</tr>
<tr>
<td><strong>Estructura interna</strong></td>
<td>Árbol binario balanceado (Red-Black Tree)</td>
<td>Árbol binario balanceado (Red-Black Tree)</td>
</tr>
<tr>
<td><strong>Complejidad</strong></td>
<td>Inserción, búsqueda y borrado en <strong>O(log n)</strong></td>
<td>Inserción, búsqueda y borrado en <strong>O(log n)</strong></td>
</tr>
<tr>
<td><strong>Variantes con duplicados</strong></td>
<td><code>std::multiset</code></td>
<td><code>std::multimap</code></td>
</tr>
</tbody>
</table><h3 id="métodos-básicos-de-librería-stdset-y-stdmap">Métodos básicos de librería <code>std::set</code> y <code>std::map</code></h3>
<p><strong>Métodos de inserción</strong></p>
<ul>
<li><code>insert(valor)</code>: Inserta un elemento en el set (si no existe).</li>
<li><code>insert(clave, valor)</code>: Inserta un elemento en el map (si no existe).</li>
<li><code>insert(hint, valor)</code>: Inserta con una posición sugerida (optimiza si el orden es conocido).</li>
<li><code>insert(rango_inicio, rango_fin)</code>: Inserta un rango de elementos de otro contenedor.</li>
</ul>
<p><strong>Métodos de eliminación</strong></p>
<ul>
<li><code>erase(valor)</code>: Elimina el elemento igual a <code>valor</code> (si existe).</li>
<li><code>erase(iterador)</code>: Elimina el elemento apuntado por el iterador.</li>
<li><code>erase(rango_inicio, rango_fin)</code>: Elimina un rango de elementos.</li>
<li><code>clear()</code>: Borra todos los elementos del set.</li>
</ul>
<p><strong>Métodos de búsqueda</strong></p>
<ul>
<li><code>find(valor)</code>: Devuelve un iterador al elemento si existe, o <code>end()</code> si no.</li>
<li><code>count(valor)</code>: Devuelve <code>1</code> si el valor existe, <code>0</code> si no.</li>
<li><code>lower_bound(valor)</code>: Devuelve iterador al primer elemento <strong>≥ valor</strong>.</li>
</ul>
<p><strong>Métodos de iteración</strong></p>
<ul>
<li><code>begin()</code>: Iterador al primer elemento (menor).</li>
<li><code>end()</code>: Iterador “uno más allá” del último elemento.</li>
</ul>
<p><strong>Métodos de capacidad</strong></p>
<ul>
<li><code>size()</code>: Retorna el número de elementos.</li>
<li><code>empty()</code>: Retorna <code>true</code> si está vacío.</li>
</ul>
<h2 id="métodos-básicos-de-librerías-stdset-y-stdmap">Métodos básicos de librerías <code>std::set</code> y <code>std::map</code></h2>
<h3 id="métodos-de-inserción">Métodos de inserción</h3>
<ul>
<li><code>insert(valor)</code>: Inserta un elemento en el <code>set</code> (si no existe).</li>
<li><code>insert(clave, valor)</code>: Inserta un nuevo par en el <code>map</code> con la <strong>clave</strong> y el <strong>valor</strong> (si la clave no existe).</li>
<li><code>insert(hint, valor)</code>: Inserta un elemento con una <strong>posición sugerida</strong>.
<ul>
<li><code>hint</code>: Iterador que indica el lugar aproximado de inserción.</li>
<li><code>valor</code>: Elemento a insertar.</li>
<li>Optimiza la inserción cuando el orden es conocido previamente.</li>
</ul>
</li>
<li><code>insert(rango_inicio, rango_fin)</code>: Inserta un <strong>rango completo de elementos</strong> desde otro contenedor.
<ul>
<li><code>rango_inicio</code>: Iterador al inicio del rango.</li>
<li><code>rango_fin</code>: Iterador al final del rango.</li>
<li>Copia los elementos dentro del rango en el contenedor actual.</li>
</ul>
</li>
</ul>
<h3 id="métodos-de-eliminación">Métodos de eliminación</h3>
<ul>
<li><code>erase(valor)</code>:
<ul>
<li>En <code>set</code>: Elimina el <strong>valor</strong> especificado (si existe).</li>
<li>En <code>map</code>: Elimina el elemento con la <strong>clave</strong> indicada.</li>
</ul>
</li>
<li><code>erase(iterador)</code>:
<ul>
<li>Elimina el elemento apuntado por el <strong>iterador</strong>.</li>
<li>Parámetro: iterador válido dentro del contenedor.</li>
</ul>
</li>
<li><code>erase(rango_inicio, rango_fin)</code>:
<ul>
<li>Elimina todos los elementos comprendidos en el <strong>rango</strong> indicado.</li>
<li>Parámetros: iteradores de inicio y fin del rango.</li>
</ul>
</li>
<li><code>clear()</code>:
<ul>
<li>Elimina <strong>todos los elementos</strong> del contenedor, dejándolo vacío.</li>
<li>No recibe parámetros.</li>
</ul>
</li>
</ul>
<h3 id="métodos-de-búsqueda">Métodos de búsqueda</h3>
<ul>
<li><code>find(valor)</code>:
<ul>
<li>En <code>set</code>: Busca el <strong>valor</strong> y devuelve un iterador a él (o <code>end()</code> si no existe).</li>
<li>En <code>map</code>: Busca la <strong>clave</strong> y devuelve un iterador al par correspondiente (o <code>end()</code> si no existe).</li>
</ul>
</li>
<li><code>count(valor)</code>:
<ul>
<li>En <code>set</code>: Devuelve <code>1</code> si el <strong>valor</strong> existe, <code>0</code> si no.</li>
<li>En <code>map</code>: Devuelve <code>1</code> si la <strong>clave</strong> existe, <code>0</code> si no.</li>
</ul>
</li>
<li><code>lower_bound(valor)</code>:
<ul>
<li>Devuelve un <strong>iterador</strong> al primer elemento <strong>≥ valor</strong> (o <strong>≥ clave</strong> en <code>map</code>).</li>
<li>Útil para buscar rangos dentro del contenedor ordenado.</li>
</ul>
</li>
<li><code>upper_bound(valor)</code>:
<ul>
<li>Devuelve un <strong>iterador</strong> al primer elemento <strong>&gt; valor</strong> (o <strong>&gt; clave</strong> en <code>map</code>).</li>
<li>Permite definir el final de un rango de búsqueda.</li>
</ul>
</li>
</ul>
<h3 id="métodos-de-iteración">Métodos de iteración</h3>
<ul>
<li><code>begin()</code>:
<ul>
<li>Devuelve un <strong>iterador al primer elemento</strong> (el menor en orden).</li>
<li>En <code>map</code>, el primer elemento corresponde a la <strong>clave más pequeña</strong>.</li>
</ul>
</li>
<li><code>end()</code>:
<ul>
<li>Devuelve un <strong>iterador “uno más allá”</strong> del último elemento (no accesible directamente).</li>
<li>Se usa para determinar el final en los bucles de recorrido.</li>
</ul>
</li>
<li><code>rbegin()</code>:
<ul>
<li>Devuelve un <strong>iterador inverso</strong> al último elemento (mayor en orden).</li>
</ul>
</li>
<li><code>rend()</code>:
<ul>
<li>Devuelve un <strong>iterador inverso “uno antes” del primero</strong>.</li>
</ul>
</li>
</ul>
<h3 id="métodos-de-capacidad">Métodos de capacidad</h3>
<ul>
<li><code>size()</code>:
<ul>
<li>Retorna el <strong>número total de elementos</strong> almacenados en el contenedor.</li>
<li>Tipo de retorno: <code>size_t</code>.</li>
</ul>
</li>
<li><code>empty()</code>:
<ul>
<li>Retorna <code>true</code> si el contenedor está <strong>vacío</strong>, <code>false</code> en caso contrario.</li>
<li>No recibe parámetros.</li>
</ul>
</li>
<li><code>max_size()</code>:
<ul>
<li>Devuelve el <strong>número máximo de elementos</strong> que el contenedor puede almacenar según el sistema.</li>
</ul>
</li>
</ul>
<h2 id="ejemplo-1-registro-de-visitantes-frecuentes-uso-de-set">Ejemplo 1: Registro de visitantes frecuentes (uso de <code>set</code>)</h2>
<h3 id="el-museo-nacional-desea-registrar-a-sus-visitantes-frecuentes.">El museo nacional desea registrar a sus visitantes frecuentes.</h3>
<p>Cada visitante tiene un número de documento, nombre y categoría (estudiante, docente o público general).<br>
El sistema debe evitar duplicados y mantener los visitantes <strong>ordenados automáticamente</strong>.</p>
<p>Utiliza <strong>set</strong> para almacenar a los visitantes, ya que este contenedor evita repetidos y mantiene los datos ordenados.</p>
<p><strong>Funciones a implementar:</strong></p>
<ul>
<li><strong>Registrar Visitante:</strong> Inserta un visitante nuevo. Si el documento ya existe, muestra un mensaje de error.</li>
<li><strong>Buscar Visitante:</strong> Dado el documento, muestra su información.</li>
<li><strong>Eliminar Visitante:</strong> Elimina un visitante usando su documento.</li>
<li><strong>Mostrar Visitantes:</strong> Muestra todos los visitantes registrados en orden.</li>
<li><strong>Registrar desde Lista:</strong> Inserta varios visitantes de otra lista usando un rango.</li>
<li><strong>Contar Visitante:</strong> Verifica si un documento está registrado.</li>
<li><strong>Mostrar desde Documento:</strong> Usa <code>lower_bound</code> para mostrar visitantes desde un valor dado.</li>
<li><strong>Mostrar Cantidad:</strong> Indica cuántos visitantes hay registrados.</li>
<li><strong>Limpiar Registro:</strong> Elimina todos los visitantes (clear).</li>
</ul>
<p><strong>Validaciones:</strong><br>
No permitir duplicados ni campos vacíos. Mostrar mensaje si el visitante no existe al eliminar o buscar.</p>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;set&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword">struct</span> Visitante <span class="token punctuation">{</span>
    string documento<span class="token punctuation">;</span>
    string nombre<span class="token punctuation">;</span>
    string categoria<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Comparador para ordenar por documento</span>
<span class="token keyword">struct</span> CompVisitante <span class="token punctuation">{</span>
    bool <span class="token function">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> Visitante<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> Visitante<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> a<span class="token punctuation">.</span>documento <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>documento<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>El código fuente completo correspondiente a este ejercicio presentado en esta guía se encuentra disponible en el repositorio oficial del curso en <strong>GitHub</strong> en <a href="https://github.com/UCASV/RecursosExtraPED/blob/main/ArbolesBinarios/EjercicioSet.cc">EjercicioSet</a>.</p>
<h2 id="ejemplo-2-sistema-de-inventario-de-ferretería-uso-de-map">Ejemplo 2: Sistema de inventario de ferretería (uso de <code>map</code>)</h2>
<h3 id="una-ferretería-necesita-un-sistema-para-registrar-sus-productos.">Una ferretería necesita un sistema para registrar sus productos.</h3>
<p>Cada producto tiene un código único, nombre, categoría, precio y cantidad en existencia.<br>
El sistema debe mantener los productos <strong>ordenados por código</strong> y permitir actualizaciones rápidas.</p>
<p>Utiliza <strong>map</strong> para almacenar los productos, donde la llave sea el código.</p>
<p><strong>Funciones a implementar:</strong></p>
<ul>
<li><strong>Agregar Producto:</strong> Inserta un nuevo producto si el código no existe.</li>
<li><strong>Actualizar Producto:</strong> Usa el acceso directo para modificar el precio o cantidad.</li>
<li><strong>Buscar Producto:</strong> Muestra la información de un producto dado su código.</li>
<li><strong>Eliminar Producto:</strong> Elimina un producto usando su código.</li>
<li><strong>Mostrar Inventario:</strong> Muestra todos los productos en orden ascendente.</li>
<li><strong>Buscar por Rango:</strong> Usa <code>lower_bound</code> y <code>upper_bound</code> para mostrar productos con código mayor o igual a uno dado.</li>
<li><strong>Contar Productos:</strong> Indica el total de registros.</li>
<li><strong>Limpiar Inventario:</strong> Vacía todo el registro.</li>
</ul>
<p><strong>Validaciones:</strong><br>
No permitir precios o existencias negativas, ni códigos duplicados o vacíos.</p>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;map&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword">struct</span> Producto <span class="token punctuation">{</span>
    string nombre<span class="token punctuation">;</span>
    string categoria<span class="token punctuation">;</span>
    <span class="token keyword">double</span> precio<span class="token punctuation">;</span>
    <span class="token keyword">int</span> stock<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">mostrarCantidad</span><span class="token punctuation">(</span><span class="token keyword">const</span> map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> Producto<span class="token operator">&gt;</span><span class="token operator">&amp;</span> inventario<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Total de productos: "</span> <span class="token operator">&lt;&lt;</span> inventario<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>El código fuente completo correspondiente a este ejercicio presentado en esta guía se encuentra disponible en el repositorio oficial del curso en <strong>GitHub</strong> en <a href="https://github.com/UCASV/RecursosExtraPED/blob/main/ArbolesBinarios/EjercicioMap.cc">EjercicioMap</a>.</p>
<h1 id="anexos">Anexos</h1>
<ul>
<li>
<p><a href="https://en.cppreference.com/w/cpp/container/set">Referencia oficial de la librería <code>std::set</code></a> — Documentación técnica oficial que describe en detalle la implementación, propiedades y operaciones del contenedor <code>std::set</code> en C++, parte de la Biblioteca Estándar (STL).</p>
</li>
<li>
<p><a href="https://www.geeksforgeeks.org/set-in-cpp-stl/">Introducción a <code>set</code> en la STL de C++ — GeeksforGeeks</a> — Recurso educativo que ofrece una explicación práctica sobre el uso del contenedor <code>set</code>, acompañado de ejemplos de código y análisis de su comportamiento interno.</p>
</li>
<li>
<p><a href="https://visualgo.net/en/bst">Visualización interactiva de estructuras de datos — Binary Search Tree (BST)</a> — Herramienta visual que permite observar el funcionamiento dinámico de los árboles binarios de búsqueda. Ideal para comprender de forma gráfica los procesos de inserción, búsqueda y eliminación en estructuras jerárquicas.</p>
</li>
<li>
<p><a href="https://www.enjoyalgorithms.com/blog/binary-tree-traversals-preorder-inorder-postorder">Binary Tree Traversals — Preorder, Inorder, and Postorder (EnjoyAlgorithms)</a> — Artículo académico que explica de manera clara los tres recorridos fundamentales de los árboles binarios (preorden, inorden y postorden). Incluye diagramas ilustrativos, pseudocódigo y ejemplos en C++ y Python, reforzando la comprensión de las operaciones de recorrido recursivo.</p>
</li>
<li>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">Red/Black Tree Visualization — University of San Francisco</a> — Herramienta interactiva desarrollada por la <em>University of San Francisco</em> que permite visualizar el funcionamiento interno de los <strong>árboles rojo-negro</strong>, una estructura de datos auto-balanceada. Presenta de forma animada los procesos de inserción, eliminación y rotación de nodos, facilitando la comprensión del equilibrio dinámico de este tipo de árbol binario de búsqueda.</p>
</li>
<li>
<p><a href="https://www.geeksforgeeks.org/dsa/introduction-to-red-black-tree/">Introduction to Red-Black Tree – GeeksforGeeks</a> — Explica la estructura y funcionamiento de los <strong>árboles Red-Black</strong>, base interna de <code>std::map</code> y <code>std::set</code>. Describe sus reglas de balanceo, ventajas en eficiencia y cómo garantizan operaciones rápidas de búsqueda e inserción.</p>
</li>
<li>
<p><a href="https://www.walletfox.com/course/mapwithcustomclasskey.php">Using std::map with a custom class key – Walletfox</a> — Muestra cómo usar <code>std::map</code> con <strong>claves personalizadas</strong>, definiendo comparadores o el operador <code>&lt;</code> para mantener el orden de los elementos. Incluye ejemplos prácticos con clases.</p>
</li>
<li>
<p><a href="https://www.programiz.com/cpp-programming/map">C++ Map – Programiz</a> — Ofrece una guía básica sobre <code>std::map</code>, explicando su estructura de pares clave-valor, sus métodos principales (<code>insert</code>, <code>erase</code>, <code>find</code>, <code>[]</code>) y ejemplos de recorrido y acceso ordenado.</p>
</li>
</ul>

    </div>
  </div>
</body>

</html>
